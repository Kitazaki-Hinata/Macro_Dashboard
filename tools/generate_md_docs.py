from __future__ import annotations

import ast
import os
import sys
from typing import List, Tuple, Optional

HEADER = """<!-- Auto-generated API docs. Do not edit by hand. -->
# {title}

- Source: `{relpath}`
- Generated by `tools/generate_md_docs.py`

---
"""


def read_text(path: str) -> str:
    with open(path, 'r', encoding='utf-8') as f:
        return f.read()


def safe_relpath(path: str, root: str) -> str:
    try:
        return os.path.relpath(path, root).replace('\\', '/')
    except Exception:
        return path


def md_escape(s: str) -> str:
    return s.replace('<', '&lt;').replace('>', '&gt;')


def render_docstring(doc: Optional[str]) -> str:
    if not doc:
        return "_No docstring._\n"
    return doc.strip() + "\n"


def get_signature(func: ast.AST) -> str:
    if not isinstance(func, (ast.FunctionDef, ast.AsyncFunctionDef)):
        return "()"
    args = func.args
    parts: List[str] = []
    # positional-only
    if getattr(args, 'posonlyargs', None):
        for a in args.posonlyargs:
            parts.append(a.arg)
        if args.posonlyargs:
            parts.append('/')
    # args
    for a in args.args:
        parts.append(a.arg)
    # vararg
    if args.vararg:
        parts.append('*' + args.vararg.arg)
    # kwonly
    if args.kwonlyargs:
        if not args.vararg:
            parts.append('*')
        for a in args.kwonlyargs:
            parts.append(a.arg)
    # kwvar
    if args.kwarg:
        parts.append('**' + args.kwarg.arg)
    return '(' + ', '.join(parts) + ')'


def walk_module(py_path: str, root: str) -> str:
    src = read_text(py_path)
    tree = ast.parse(src)
    title = os.path.basename(py_path)
    out: List[str] = [HEADER.format(title=title, relpath=safe_relpath(py_path, root))]

    # module doc
    out.append("## Module doc\n\n")
    out.append(render_docstring(ast.get_docstring(tree)))

    # top-level functions
    functions = [n for n in tree.body if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef))]
    if functions:
        out.append("\n## Functions\n\n")
        for fn in functions:
            sig = get_signature(fn)
            out.append(f"### {fn.name}{md_escape(sig)}\n\n")
            out.append(render_docstring(ast.get_docstring(fn)))

    # classes
    classes = [n for n in tree.body if isinstance(n, ast.ClassDef)]
    if classes:
        out.append("\n## Classes\n\n")
        for cls in classes:
            out.append(f"### class {cls.name}\n\n")
            out.append(render_docstring(ast.get_docstring(cls)))
            # methods
            methods = [n for n in cls.body if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef))]
            for m in methods:
                sig = get_signature(m)
                out.append(f"#### {cls.name}.{m.name}{md_escape(sig)}\n\n")
                out.append(render_docstring(ast.get_docstring(m)))

    return ''.join(out)


def discover_py_files(root: str) -> List[str]:
    out: List[str] = []
    for dirpath, dirnames, filenames in os.walk(root):
        # skip caches and vendor assets
        if any(x in dirpath for x in ("__pycache__", ".venv", "venv", "env", "node_modules")):
            continue
        if os.path.basename(dirpath) in ("doc", "logs", "cache"):
            continue
        for fn in filenames:
            if fn.endswith('.py'):
                out.append(os.path.join(dirpath, fn))
    return sorted(out)


def main() -> int:
    repo_root = os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))
    out_dir = os.path.join(repo_root, 'doc', 'md')
    os.makedirs(out_dir, exist_ok=True)

    py_files = discover_py_files(repo_root)
    if not py_files:
        print('No Python files found.')
        return 0

    for path in py_files:
        try:
            rel = safe_relpath(path, repo_root)
            name = rel.replace('/', '__')
            md_path = os.path.join(out_dir, f'{name}.md')
            content = walk_module(path, repo_root)
            with open(md_path, 'w', encoding='utf-8') as f:
                f.write(content)
            print(f'Wrote {md_path}')
        except Exception as e:
            print(f'WARN: failed to document {path}: {e}')
    print('Done.')
    return 0


if __name__ == '__main__':
    raise SystemExit(main())
